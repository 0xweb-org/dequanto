/** Autogenerated with "atma act ./actions/rpc.act.ts" */

import { DataLike } from '@dequanto/utils/types';
import { TEth } from '@dequanto/models/TEth';
import { RpcBase } from '@dequanto/rpc/RpcBase';
import { RpcSubscription, RpcLogFilterOptions } from '@dequanto/rpc/RpcSubscription';
//import { RpcHandler, RpcTransport } from '@dequanto/rpc/RpcHandler';
export class Rpc extends RpcBase {

/**
 * Subscribes to specific Ethereum events, returning a subscription ID used to receive notifications. <metamask> 
 * The eth_subscribe method allows clients to subscribe to specific events on the Ethereum network, such as new blocks, new pending transactions, or changes in the state of an account. When an event occurs, a notification is sent to the client with the corresponding data. To stop receiving notifications, the client can unsubscribe using the eth_unsubscribe method.
 * @param subscriptionType - The type of subscription to create. Must be one of:`newHeads`: new block headers - `logs`: logs matching a filter object - `newPendingTransactions`: new pending transactions - `syncing`: changes in syncing status
 * @param filterOptions - An optional object containing filter options specific to the subscription type. Only applicable for 'logs' subscription type.
 * @returns subscriptionId - A unique subscription ID that can be used to unsubscribe or identify incoming notifications.
 */
eth_subscribe(type: 'newHeads'): Promise<RpcSubscription<TEth.Block>>
eth_subscribe(type: 'logs', options: RpcLogFilterOptions): Promise<RpcSubscription<TEth.Log>>
eth_subscribe(type: 'newPendingTransactions'): Promise<RpcSubscription<TEth.Tx>>
eth_subscribe(type: any, options?): Promise<RpcSubscription<any>> {
    return this.subscribe({ method: 'eth_subscribe', params: Array.from(arguments) })
}

/**
 * Unsubscribes from a specific Ethereum event, using the subscription ID provided by eth_subscribe. <metamask> 
 * The eth_unsubscribe method allows clients to unsubscribe from specific events on the Ethereum network, to which they have previously subscribed using the eth_subscribe method. The client needs to provide the subscription ID obtained from eth_subscribe to stop receiving notifications for the corresponding event.
 * @param subscriptionId - The unique subscription ID obtained from the eth_subscribe method, used to identify the subscription to be unsubscribed.
 * @returns unsubscribed - A boolean value indicating whether the unsubscription was successful.
 */
eth_unsubscribe(subscriptionId: string): Promise<boolean> {
    return this.request({ method: 'eth_unsubscribe', params: Array.from(arguments) })
}

/**
 * Adds an Ethereum chain to the wallet. <metamask> 
 * Creates a confirmation asking the user to add the specified chain to the wallet application. The caller must specify a chain ID and some chain metadata. The wallet application may refuse or accept the request. `null` is returned if the chain is added, and an error otherwise. Introduced by [EIP 3085](https://eips.ethereum.org/EIPS/eip-3085).
 * @param addEthereumChainParameter - 
 * @returns AddEthereumChainResult - 
 */
wallet_addEthereumChain(addEthereumChainParameter?: DataLike<RpcTypes.AddEthereumChainParameter>): Promise<undefined> {
    return this.request({ method: 'wallet_addEthereumChain', params: Array.from(arguments) })
}

/**
 * Switches the wallet's active Ethereum chain. <metamask> 
 * Requests that the wallet switches its active Ethereum chain. Introduced by [EIP 3326](https://ethereum-magicians.org/t/eip-3326-wallet-switchethereumchain).
 * @param switchEthereumChainParameter - 
 * @returns SwitchEthereumChainResult - 
 */
wallet_switchEthereumChain(switchEthereumChainParameter?: {
    chainId: string;
}): Promise<undefined> {
    return this.request({ method: 'wallet_switchEthereumChain', params: Array.from(arguments) })
}

/**
 * Requests additional permissions. <metamask> 
 * Requests additional permissions from the user. Introduced by [EIP-2255](https://eips.ethereum.org/EIPS/eip-2255).
 * @param requestPermissionsObject - 
 * @returns PermissionsList - 
 */
wallet_requestPermissions(requestPermissionsObject: {
    eth_accounts: {
        [key: string]: any
    };
    [key: string]: {
        [key: string]: any
    }
}): Promise<RpcTypes.Permission[]> {
    return this.request({ method: 'wallet_requestPermissions', params: Array.from(arguments) })
}

/**
 * Gets the user's permissions. <metamask> 
 * Gets the user's permissions. Introduced by [EIP-2255](https://eips.ethereum.org/EIPS/eip-2255).
 * @returns PermissionsList - 
 */
wallet_getPermissions(): Promise<RpcTypes.Permission[]> {
    return this.request({ method: 'wallet_getPermissions', params: Array.from(arguments) })
}

/**
 * Redirects the user back to the site after onboarding. <metamask> 
 * Registers the requesting site with MetaMask as the initiator of onboarding, enabling MetaMask to redirect the user back to the site after onboarding. Returns a promise that resolves to `true`, or rejects if there's an error. Instead of calling this method directly, you should use the [`@metamask/onboarding`](https://github.com/MetaMask/metamask-onboarding) library.
 * @returns RegisterOnboardingResult - `true` if the request was successful, `false` otherwise.
 */
wallet_registerOnboarding(): Promise<boolean> {
    return this.request({ method: 'wallet_registerOnboarding', params: Array.from(arguments) })
}

/**
 * Tracks a token in MetaMask. <metamask> 
 * Requests that the user track the specified token in MetaMask. Returns a boolean indicating if the token was successfully added. Once added, the token is indistinguishable from those added using legacy methods, such as a centralized registry. Introduced by [EIP-747](https://eips.ethereum.org/EIPS/eip-747). Currently support for ERC721 and ERC1155 tokens is limited to the extension (not on mobile) and is considered experimental. See [MIP-1](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md) and [MIP proposal lifecycle](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle) for more information.
 * @param type - Supports ERC-20, ERC-721, and ERC-1155 tokens. Currently support for ERC721 and ERC1155 tokens is limited to the extension (not on mobile) and is considered experimental. See [MIP-1](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md) and [MIP proposal lifecycle](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle) for more information.
 * @param options - 
 * @returns WatchAssetResult - `true` if the token was added, `false` otherwise.
 */
wallet_watchAsset(type: 'ERC20' | 'ERC721' | 'ERC1155', options?: {
    address: string;
    symbol: string;
    decimals: number;
    image: string;
    tokenId: string;
}): Promise<boolean> {
    return this.request({ method: 'wallet_watchAsset', params: Array.from(arguments) })
}

/**
 * Decrypts an encrypted message. <metamask> 
 * Requests that MetaMask decrypt the specified encrypted message. The message must have been encrypted using the public encryption key of the specified Ethereum address. Returns a promise that resolves to the decrypted message, or rejects if the decryption attempt fails.
 * @param encryptedMessage - The encrypted message to decrypt.
 * @param address - The address of the Ethereum account that can decrypt the message.
 * @returns PermissionsList - 
 */
eth_decrypt(encryptedMessage: string, address: TEth.Address): Promise<RpcTypes.Permission[]> {
    return this.request({ method: 'eth_decrypt', params: Array.from(arguments) })
}

/**
 * Gets a public key used for encryption. <metamask> 
 * Requests that the user share their public encryption key. Returns a public encryption key, or rejects if the user denies the request. The public key is computed from entropy associated with the specified user account, using the NaCl implementation of the `X25519_XSalsa20_Poly1305` algorithm.
 * @param address - The address of the Ethereum account that can decrypt the message.
 * @returns EncryptionKey - 
 */
eth_getEncryptionPublicKey(address: TEth.Address): Promise<string> {
    return this.request({ method: 'eth_getEncryptionPublicKey', params: Array.from(arguments) })
}

/**
 * Requests that the user provide an Ethereum address. <metamask> 
 * Requests that the user provide an Ethereum address to be identified by. This method is specified by [EIP-1102](https://eips.ethereum.org/EIPS/eip-1102). Internally, this method calls `wallet_requestPermissions` for permission to call `eth_accounts`.
 * @returns AddressList - 
 */
eth_requestAccounts(): Promise<TEth.Address[]> {
    return this.request({ method: 'eth_requestAccounts', params: Array.from(arguments) })
}

/**
 * Gets a list of addresses for the user's accounts. <metamask | eth> 
 * Returns a list of addresses for the accounts owned by the user.
 * @returns AddressList - 
 */
eth_accounts(): Promise<TEth.Address[]> {
    return this.request({ method: 'eth_accounts', params: Array.from(arguments) })
}

/**
 * Presents a structured data message for the user to sign. <metamask> 
 * Presents a data message for the user to sign in a structured and readable format and returns the signed response. Introduced By [EIP-712](https://eips.ethereum.org/EIPS/eip-712).
 * @param address - The address of the requested signing account.
 * @param typedData - 
 * @returns Signature - 
 */
eth_signTypedData_v4(address: TEth.Address, typedData: DataLike<RpcTypes.TypedData>): Promise<TEth.Hex> {
    return this.request({ method: 'eth_signTypedData_v4', params: Array.from(arguments) })
}

/**
 * Presents a plain text signature challenge to the user. <metamask> 
 * Presents a plain text signature challenge to the user and returns the signed response. Equivalent to `eth_sign` on some other wallets, and prepends a safe prefix to the signed message to prevent the challenge tricking users into signing a financial transaction. This method requires that the user has granted permission to interact with their account first, so make sure to call `eth_requestAccounts` first.
 * @param challenge - A hex-encoded UTF-8 string to present to the user. See how to encode a string like this in the [`browser-string-hexer`](https://github.com/danfinlay/browser-string-hexer) module.
 * @param address - The address of the requested signing account.
 * @returns Signature - A hex-encoded 129-byte array starting with `0x`.
 */
personal_sign(challenge: string, address: TEth.Address): Promise<TEth.Hex> {
    return this.request({ method: 'personal_sign', params: Array.from(arguments) })
}

/**
 * Initiates a new transaction. <metamask | eth> 
 * Creates a new wallet confirmation to make an ethereum transaction from the user's account. This method requires that the user has granted permission to interact with their account first, so make sure to call `eth_requestAccounts` or `wallet_requestPermissions` first.
 * @param transaction - The transaction object to sign and send.
 * @returns TransactionHash - The transaction hash of the sent transaction.
 */
eth_sendTransaction(transaction: {
    to: TEth.Address;
    from: TEth.Address;
    gas: bigint;
    value: bigint;
    data: TEth.Hex;
    gasPrice: bigint;
    maxPriorityFeePerGas: bigint;
    maxFeePerGas: bigint;
}): Promise<TEth.Hex> {
    return this.request({ method: 'eth_sendTransaction', params: Array.from(arguments) })
}

/**
 * Returns the number of most recent block. <metamask | coregeth | eth> 
 * 
 * @returns Block number - 
 */
eth_blockNumber(): Promise<number> {
    return this.request({ method: 'eth_blockNumber', params: Array.from(arguments) })
}

/**
 * Executes a new message call immediately without creating a transaction on the block chain. <metamask | coregeth | eth> 
 * 
 * @param transaction - 
 * @param block - 
 * @returns Return data - 
 */
eth_call(transaction: DataLike<RpcTypes.GenericTransaction>, block?: DataLike<RpcTypes.BlockNumberOrTagOrHash>): Promise<TEth.Hex> {
    return this.request({ method: 'eth_call', params: Array.from(arguments) })
}

/**
 * Returns the chain ID of the current network. <metamask | coregeth | eth> 
 * 
 * @returns Chain ID - 
 */
eth_chainId(): Promise<number> {
    return this.request({ method: 'eth_chainId', params: Array.from(arguments) })
}

/**
 * Returns the client coinbase address. <metamask | coregeth | eth> 
 * 
 * @returns Coinbase address - 
 */
eth_coinbase(): Promise<TEth.Address> {
    return this.request({ method: 'eth_coinbase', params: Array.from(arguments) })
}

/**
 * Generates and returns an estimate of how much gas is necessary to allow the transaction to complete. <metamask | coregeth | eth> 
 * 
 * @param transaction - 
 * @param block - 
 * @returns Gas used - 
 */
eth_estimateGas(transaction: DataLike<RpcTypes.GenericTransaction>, block?: DataLike<RpcTypes.BlockNumberOrTag>): Promise<bigint> {
    return this.request({ method: 'eth_estimateGas', params: Array.from(arguments) })
}

/**
 * Transaction fee history <metamask | eth> 
 * Returns transaction base fee per gas and effective priority fee per gas for the requested/supported block range.
 * @param blockCount - Requested range of blocks. Clients will return less than the requested range if not all blocks are available.
 * @param newestBlock - Highest block of the requested range.
 * @param rewardPercentiles - A monotonically increasing list of percentile values. For each block in the requested range, the transactions will be sorted in ascending order by effective tip per gas and the coresponding effective tip for the percentile will be determined, accounting for gas consumed.
 * @returns feeHistoryResult - Fee history for the returned block range. This can be a subsection of the requested range if not all blocks are available.
 */
eth_feeHistory(blockCount: bigint, newestBlock: DataLike<RpcTypes.BlockNumberOrTag>, rewardPercentiles: number[]): Promise<{
    oldestBlock: bigint;
    /* baseFeePerGasArray */
    baseFeePerGas: bigint[];
    /* gasUsedRatio */
    gasUsedRatio: number[];
    /* rewardArray */
    reward: bigint[][];
}> {
    return this.request({ method: 'eth_feeHistory', params: Array.from(arguments) })
}

/**
 * Returns the current price per gas in wei. <metamask | coregeth | eth> 
 * 
 * @returns Gas price - 
 */
eth_gasPrice(): Promise<bigint> {
    return this.request({ method: 'eth_gasPrice', params: Array.from(arguments) })
}

/**
 * Returns the balance of the account of given address. <metamask | coregeth | eth> 
 * 
 * @param address - 
 * @param block - 
 * @returns Balance - 
 */
eth_getBalance(address: TEth.Address, block?: DataLike<RpcTypes.BlockNumberOrTagOrHash>): Promise<bigint> {
    return this.request({ method: 'eth_getBalance', params: Array.from(arguments) })
}

/**
 * Returns information about a block by hash. <metamask | coregeth | eth> 
 * 
 * @param blockHash - 
 * @param hydratedTransactions - 
 * @returns Block information - 
 */
eth_getBlockByHash(blockHash: TEth.Hex, hydratedTransactions: boolean): Promise<RpcTypes.Block> {
    return this.request({ method: 'eth_getBlockByHash', params: Array.from(arguments) })
}

/**
 * Returns information about a block by number. <metamask | coregeth | eth> 
 * 
 * @param block - 
 * @param hydratedTransactions - 
 * @returns Block information - 
 */
eth_getBlockByNumber(block: DataLike<RpcTypes.BlockNumberOrTag>, hydratedTransactions: boolean): Promise<RpcTypes.Block> {
    return this.request({ method: 'eth_getBlockByNumber', params: Array.from(arguments) })
}

/**
 * Returns the number of transactions in a block from a block matching the given block hash. <metamask | coregeth | eth> 
 * 
 * @param blockHash - 
 * @returns Transaction count - 
 */
eth_getBlockTransactionCountByHash(blockHash?: TEth.Hex): Promise<bigint> {
    return this.request({ method: 'eth_getBlockTransactionCountByHash', params: Array.from(arguments) })
}

/**
 * Returns the number of transactions in a block matching the given block number. <metamask | coregeth | eth> 
 * 
 * @param block - 
 * @returns Transaction count - 
 */
eth_getBlockTransactionCountByNumber(block?: DataLike<RpcTypes.BlockNumberOrTag>): Promise<bigint> {
    return this.request({ method: 'eth_getBlockTransactionCountByNumber', params: Array.from(arguments) })
}

/**
 * Returns code at a given address. <metamask | coregeth | eth> 
 * 
 * @param address - 
 * @param block - 
 * @returns Bytecode - 
 */
eth_getCode(address: TEth.Address, block: DataLike<RpcTypes.BlockNumberOrTagOrHash>): Promise<TEth.Hex> {
    return this.request({ method: 'eth_getCode', params: Array.from(arguments) })
}

/**
 * Polling method for a filter, which returns an array of logs which occurred since last poll. <metamask | coregeth | eth> 
 * 
 * @param filterIdentifier - 
 * @returns Log objects - 
 */
eth_getFilterChanges(filterIdentifier?: bigint): Promise<RpcTypes.FilterResults> {
    return this.request({ method: 'eth_getFilterChanges', params: Array.from(arguments) })
}

/**
 * Returns an array of all logs matching filter with given id. <metamask | coregeth | eth> 
 * 
 * @param filterIdentifier - 
 * @returns Log objects - 
 */
eth_getFilterLogs(filterIdentifier?: bigint): Promise<RpcTypes.FilterResults> {
    return this.request({ method: 'eth_getFilterLogs', params: Array.from(arguments) })
}

/**
 * Returns an array of all logs matching filter with given id. <metamask | coregeth | eth> 
 * 
 * @param filter - 
 * @returns Log objects - 
 */
eth_getLogs(filter?: DataLike<RpcTypes.Filter>): Promise<RpcTypes.FilterResults> {
    return this.request({ method: 'eth_getLogs', params: Array.from(arguments) })
}

/**
 * Returns the merkle proof for a given account and optionally some storage keys. <metamask | coregeth | eth> 
 * 
 * @param address - 
 * @param storageKeys - 
 * @param block - 
 * @returns Account - 
 */
eth_getProof(address: TEth.Address, storageKeys: TEth.Hex[], block: DataLike<RpcTypes.BlockNumberOrTagOrHash>): Promise<RpcTypes.AccountProof> {
    return this.request({ method: 'eth_getProof', params: Array.from(arguments) })
}

/**
 * Returns the value from a storage position at a given address. <metamask | coregeth | eth> 
 * 
 * @param address - 
 * @param storageSlot - 
 * @param block - 
 * @returns Value - 
 */
eth_getStorageAt(address: TEth.Address, storageSlot: bigint, block?: DataLike<RpcTypes.BlockNumberOrTagOrHash>): Promise<TEth.Hex> {
    return this.request({ method: 'eth_getStorageAt', params: Array.from(arguments) })
}

/**
 * Returns information about a transaction by block hash and transaction index position. <metamask | coregeth | eth> 
 * 
 * @param blockHash - 
 * @param transactionIndex - 
 * @returns Transaction information - 
 */
eth_getTransactionByBlockHashAndIndex(blockHash: TEth.Hex, transactionIndex: bigint): Promise<RpcTypes.TransactionInfo> {
    return this.request({ method: 'eth_getTransactionByBlockHashAndIndex', params: Array.from(arguments) })
}

/**
 * Returns information about a transaction by block number and transaction index position. <metamask | coregeth | eth> 
 * 
 * @param block - 
 * @param transactionIndex - 
 * @returns Transaction information - 
 */
eth_getTransactionByBlockNumberAndIndex(block: DataLike<RpcTypes.BlockNumberOrTag>, transactionIndex: bigint): Promise<RpcTypes.TransactionInfo> {
    return this.request({ method: 'eth_getTransactionByBlockNumberAndIndex', params: Array.from(arguments) })
}

/**
 * Returns the information about a transaction requested by transaction hash. <metamask | coregeth | eth> 
 * 
 * @param transactionHash - 
 * @returns Transaction information - 
 */
eth_getTransactionByHash(transactionHash: TEth.Hex): Promise<RpcTypes.TransactionInfo> {
    return this.request({ method: 'eth_getTransactionByHash', params: Array.from(arguments) })
}

/**
 * Returns the number of transactions sent from an address. <metamask | coregeth | eth> 
 * 
 * @param address - 
 * @param block - 
 * @returns Transaction count - 
 */
eth_getTransactionCount(address: TEth.Address, block?: DataLike<RpcTypes.BlockNumberOrTagOrHash>): Promise<bigint> {
    return this.request({ method: 'eth_getTransactionCount', params: Array.from(arguments) })
}

/**
 * Returns the receipt of a transaction by transaction hash. <metamask | coregeth | eth> 
 * 
 * @param transactionHash - 
 * @returns Receipt information - 
 */
eth_getTransactionReceipt(transactionHash: TEth.Hex): Promise<RpcTypes.ReceiptInfo> {
    return this.request({ method: 'eth_getTransactionReceipt', params: Array.from(arguments) })
}

/**
 * Returns the number of uncles in a block from a block matching the given block hash. <metamask | coregeth | eth> 
 * 
 * @param blockHash - 
 * @returns Uncle count - 
 */
eth_getUncleCountByBlockHash(blockHash?: TEth.Hex): Promise<bigint> {
    return this.request({ method: 'eth_getUncleCountByBlockHash', params: Array.from(arguments) })
}

/**
 * Returns the number of transactions in a block matching the given block number. <metamask | coregeth | eth> 
 * 
 * @param block - 
 * @returns Uncle count - 
 */
eth_getUncleCountByBlockNumber(block?: DataLike<RpcTypes.BlockNumberOrTag>): Promise<bigint> {
    return this.request({ method: 'eth_getUncleCountByBlockNumber', params: Array.from(arguments) })
}

/**
 * Returns the current maxPriorityFeePerGas per gas in wei. <metamask | eth> 
 * 
 * @returns Max priority fee per gas - 
 */
eth_maxPriorityFeePerGas(): Promise<bigint> {
    return this.request({ method: 'eth_maxPriorityFeePerGas', params: Array.from(arguments) })
}

/**
 * Creates a filter in the node, to notify when a new block arrives. <metamask | coregeth | eth> 
 * 
 * @returns Filter Identifier - 
 */
eth_newBlockFilter(): Promise<bigint> {
    return this.request({ method: 'eth_newBlockFilter', params: Array.from(arguments) })
}

/**
 * Creates a filter object, based on filter options, to notify when the state changes (logs). <metamask | coregeth | eth> 
 * 
 * @param filter - 
 * @returns Filter Identifier - 
 */
eth_newFilter(filter?: DataLike<RpcTypes.Filter>): Promise<bigint> {
    return this.request({ method: 'eth_newFilter', params: Array.from(arguments) })
}

/**
 * Creates a filter in the node, to notify when new pending transactions arrive. <metamask | coregeth | eth> 
 * 
 * @returns Filter Identifier - 
 */
eth_newPendingTransactionFilter(): Promise<bigint> {
    return this.request({ method: 'eth_newPendingTransactionFilter', params: Array.from(arguments) })
}

/**
 * Submits a raw transaction. <metamask | coregeth | eth> 
 * 
 * @param transaction - 
 * @returns Transaction hash - 
 */
eth_sendRawTransaction(transaction: TEth.Hex): Promise<TEth.Hex> {
    return this.request({ method: 'eth_sendRawTransaction', params: Array.from(arguments) })
}

/**
 * Returns an object with data about the sync status or false. <metamask | coregeth | eth> 
 * 
 * @returns Syncing status - 
 */
eth_syncing(): Promise<RpcTypes.SyncingStatus> {
    return this.request({ method: 'eth_syncing', params: Array.from(arguments) })
}

/**
 * Uninstalls a filter with given id. <metamask | coregeth | eth> 
 * 
 * @param filterIdentifier - 
 * @returns Success - 
 */
eth_uninstallFilter(filterIdentifier?: bigint): Promise<boolean> {
    return this.request({ method: 'eth_uninstallFilter', params: Array.from(arguments) })
}

/**
 * current client version <coregeth> 
 * Returns the version of the current client
 * @returns clientVersion - client version
 */
web3_clientVersion(): Promise<string> {
    return this.request({ method: 'web3_clientVersion', params: Array.from(arguments) })
}

/**
 * Hashes data <coregeth> 
 * Hashes data using the Keccak-256 algorithm
 * @param data - data to hash using the Keccak-256 algorithm
 * @returns hashedData - Keccak-256 hash of the given data
 */
web3_sha3(data?: string): Promise<string> {
    return this.request({ method: 'web3_sha3', params: Array.from(arguments) })
}

/**
 * returns listening status <coregeth> 
 * Determines if this client is listening for new network connections.
 * @returns netListeningResult - `true` if listening is active or `false` if listening is not active
 */
net_listening(): Promise<boolean> {
    return this.request({ method: 'net_listening', params: Array.from(arguments) })
}

/**
 * number of peers <coregeth> 
 * Returns the number of peers currently connected to this client.
 * @returns quantity - number of connected peers.
 */
net_peerCount(): Promise<string> {
    return this.request({ method: 'net_peerCount', params: Array.from(arguments) })
}

/**
 * Network identifier associated with network <coregeth> 
 * Returns the network ID associated with the current network.
 * @returns networkId - Network ID associated with the current network
 */
net_version(): Promise<string> {
    return this.request({ method: 'net_version', params: Array.from(arguments) })
}

/**
 * Returns raw transaction data of a transaction with the given hash. <coregeth> 
 * 
 * @param transactionHash - Hex representation of a Keccak 256 hash
 * @returns rawTransactionByHash - The raw transaction data
 */
eth_getRawTransactionByHash(transactionHash?: string): Promise<TEth.Hex> {
    return this.request({ method: 'eth_getRawTransactionByHash', params: Array.from(arguments) })
}

/**
 * Returns raw transaction data of a transaction with the block hash and index of which it was mined. <coregeth> 
 * 
 * @param blockHash - The hex representation of the Keccak 256 of the RLP encoded block
 * @param index - The ordering in which a transaction is mined within its block.
 * @returns rawTransaction - The raw transaction data
 */
eth_getRawTransactionByBlockHashAndIndex(blockHash?: string, index?: bigint): Promise<TEth.Hex> {
    return this.request({ method: 'eth_getRawTransactionByBlockHashAndIndex', params: Array.from(arguments) })
}

/**
 * Returns raw transaction data of a transaction with the block number and index of which it was mined. <coregeth> 
 * 
 * @param blockNumber - 
 * @param index - The ordering in which a transaction is mined within its block.
 * @returns rawTransaction - The raw transaction data
 */
eth_getRawTransactionByBlockNumberAndIndex(blockNumber?: bigint, index?: bigint): Promise<TEth.Hex> {
    return this.request({ method: 'eth_getRawTransactionByBlockNumberAndIndex', params: Array.from(arguments) })
}

/**
 * Returns information about a uncle of a block by hash and uncle index position. <coregeth> 
 * 
 * @param blockHash - The hex representation of the Keccak 256 of the RLP encoded block
 * @param index - The ordering in which a uncle is included within its block.
 * @returns uncle - 
 */
eth_getUncleByBlockHashAndIndex(blockHash?: string, index?: bigint): Promise<undefined> {
    return this.request({ method: 'eth_getUncleByBlockHashAndIndex', params: Array.from(arguments) })
}

/**
 * Returns information about a uncle of a block by hash and uncle index position. <coregeth> 
 * 
 * @param uncleBlockNumber - The block in which the uncle was included
 * @param index - The ordering in which a uncle is included within its block.
 * @returns uncleResult - returns an uncle block or null
 */
eth_getUncleByBlockNumberAndIndex(uncleBlockNumber: bigint, index: bigint): Promise<undefined> {
    return this.request({ method: 'eth_getUncleByBlockNumberAndIndex', params: Array.from(arguments) })
}

/**
 * Returns the hash of the current block, the seedHash, and the boundary condition to be met ('target'). <coregeth | eth> 
 * 
 * @returns work - 
 */
eth_getWork(): Promise<any[]> {
    return this.request({ method: 'eth_getWork', params: Array.from(arguments) })
}

/**
 * Returns the number of hashes per second that the node is mining with. <coregeth | eth> 
 * 
 * @returns hashesPerSecond - Integer of the number of hashes per second
 */
eth_hashrate(): Promise<bigint> {
    return this.request({ method: 'eth_hashrate', params: Array.from(arguments) })
}

/**
 * Returns true if client is actively mining new blocks. <coregeth | eth> 
 * 
 * @returns mining - Whether or not the client is mining
 */
eth_mining(): Promise<boolean> {
    return this.request({ method: 'eth_mining', params: Array.from(arguments) })
}

/**
 * Returns the transactions that are pending in the transaction pool and have a from address that is one of the accounts this node manages. <coregeth> 
 * 
 * @returns pendingTransactions - 
 */
eth_pendingTransactions(): Promise<RpcTypes.Transaction[]> {
    return this.request({ method: 'eth_pendingTransactions', params: Array.from(arguments) })
}

/**
 * Returns the current ethereum protocol version. <coregeth> 
 * 
 * @returns protocolVersion - The current ethereum protocol version
 */
eth_protocolVersion(): Promise<bigint> {
    return this.request({ method: 'eth_protocolVersion', params: Array.from(arguments) })
}

/**
 * Used for submitting mining hashrate. <coregeth | eth> 
 * 
 * @param hashRate - Hex representation of a 256 bit unit of data
 * @param id - String identifying the client
 * @returns submitHashRateSuccess - whether of not submitting went through successfully
 */
eth_submitHashrate(hashRate: string, id: string): Promise<boolean> {
    return this.request({ method: 'eth_submitHashrate', params: Array.from(arguments) })
}

/**
 * Used for submitting a proof-of-work solution. <coregeth | eth> 
 * 
 * @param nonce - 
 * @param powHash - Hex representation of a 256 bit unit of data
 * @param mixHash - Hex representation of a 256 bit unit of data
 * @returns solutionValid - returns true if the provided solution is valid, otherwise false.
 */
eth_submitWork(nonce?: bigint, powHash?: string, mixHash?: string): Promise<boolean> {
    return this.request({ method: 'eth_submitWork', params: Array.from(arguments) })
}

/**
 * Generates an access list for a transaction. <eth> 
 * 
 * @param transaction - 
 * @param block - 
 * @returns Gas used - 
 */
eth_createAccessList(transaction: {
    /* type */
    type: string;
    /* nonce */
    nonce: string;
    /* to address */
    to: string;
    /* from address */
    from: string;
    /* gas limit */
    gas: string;
    /* value */
    value: string;
    /* input data */
    input: string;
    /* gas price */
    gasPrice: string;
    /* max priority fee per gas */
    maxPriorityFeePerGas: string;
    /* max fee per gas */
    maxFeePerGas: string;
    /* accessList */
    accessList: {
            /* hex encoded address */
            address: string;
            storageKeys: string[];
        }[];
    /* chainId */
    chainId: string;
}, block?: string | 'earliest' | 'finalized' | 'safe' | 'latest' | 'pending'): Promise<{
    /* accessList */
    accessList: {
            /* hex encoded address */
            address: string;
            storageKeys: string[];
        }[];
    /* error */
    error: string;
    /* Gas used */
    gasUsed: string;
}> {
    return this.request({ method: 'eth_createAccessList', params: Array.from(arguments) })
}

/**
 * Returns an EIP-191 signature over the provided data. <eth> 
 * 
 * @param address - 
 * @param message - 
 * @returns Signature - 
 */
eth_sign(address: string, message: string): Promise<string> {
    return this.request({ method: 'eth_sign', params: Array.from(arguments) })
}

/**
 * Returns an RLP encoded transaction signed by the specified account. <eth> 
 * 
 * @param transaction - 
 * @returns Encoded transaction - 
 */
eth_signTransaction(transaction: {
    /* type */
    type: string;
    /* nonce */
    nonce: string;
    /* to address */
    to: string;
    /* from address */
    from: string;
    /* gas limit */
    gas: string;
    /* value */
    value: string;
    /* input data */
    input: string;
    /* gas price */
    gasPrice: string;
    /* max priority fee per gas */
    maxPriorityFeePerGas: string;
    /* max fee per gas */
    maxFeePerGas: string;
    /* accessList */
    accessList: {
            /* hex encoded address */
            address: string;
            storageKeys: string[];
        }[];
    /* chainId */
    chainId: string;
}): Promise<string> {
    return this.request({ method: 'eth_signTransaction', params: Array.from(arguments) })
}

/**
 * Returns an RLP-encoded header. <eth> 
 * 
 * @param block - 
 * @returns Header RLP - 
 */
debug_getRawHeader(block: string | 'earliest' | 'finalized' | 'safe' | 'latest' | 'pending'): Promise<string> {
    return this.request({ method: 'debug_getRawHeader', params: Array.from(arguments) })
}

/**
 * Returns an RLP-encoded block. <eth> 
 * 
 * @param block - 
 * @returns Block RLP - 
 */
debug_getRawBlock(block: string | 'earliest' | 'finalized' | 'safe' | 'latest' | 'pending'): Promise<string> {
    return this.request({ method: 'debug_getRawBlock', params: Array.from(arguments) })
}

/**
 * Returns an array of EIP-2718 binary-encoded transactions. <eth> 
 * 
 * @param transactionHash - 
 * @returns EIP-2718 binary-encoded transaction - 
 */
debug_getRawTransaction(transactionHash: string): Promise<string> {
    return this.request({ method: 'debug_getRawTransaction', params: Array.from(arguments) })
}

/**
 * Returns an array of EIP-2718 binary-encoded receipts. <eth> 
 * 
 * @param block - 
 * @returns Receipts - 
 */
debug_getRawReceipts(block: string | 'earliest' | 'finalized' | 'safe' | 'latest' | 'pending'): Promise<string[]> {
    return this.request({ method: 'debug_getRawReceipts', params: Array.from(arguments) })
}

/**
 * Returns an array of recent bad blocks that the client has seen on the network. <eth> 
 * 
 * @returns Blocks - 
 */
debug_getBadBlocks(): Promise<{
        /* Block */
        block: string;
        /* Hash */
        hash: string;
        /* RLP */
        rlp: string;
    }[]> {
    return this.request({ method: 'debug_getBadBlocks', params: Array.from(arguments) })
}

/**
 * Exchanges list of supported Engine API methods <eth> 
 * 
 * @param consensusClientMethods - 
 * @returns Execution client methods - 
 */
engine_exchangeCapabilities(consensusClientMethods: string[]): Promise<string[]> {
    return this.request({ method: 'engine_exchangeCapabilities', params: Array.from(arguments) })
}

/**
 * Updates the forkchoice state <eth> 
 * 
 * @param forkchoiceState - 
 * @param payloadAttributes - 
 * @returns Response object - 
 */
engine_forkchoiceUpdatedV1(forkchoiceState: {
    /* Head block hash */
    headBlockHash: string;
    /* Safe block hash */
    safeBlockHash: string;
    /* Finalized block hash */
    finalizedBlockHash: string;
}, payloadAttributes?: {
    /* Timestamp */
    timestamp: string;
    /* Previous randao value */
    prevRandao: string;
    /* Suggested fee recipient */
    suggestedFeeRecipient: string;
}): Promise<{
    /* Payload status */
    payloadStatus: {
        /* Payload validation status */
        status: 'VALID' | 'INVALID' | 'SYNCING';
        /* The hash of the most recent valid block */
        latestValidHash: string;
        /* Validation error message */
        validationError: string;
    };
    /* Payload id */
    payloadId: string;
}> {
    return this.request({ method: 'engine_forkchoiceUpdatedV1', params: Array.from(arguments) })
}

/**
 * Updates the forkchoice state <eth> 
 * 
 * @param forkchoiceState - 
 * @param payloadAttributes - 
 * @returns Response object - 
 */
engine_forkchoiceUpdatedV2(forkchoiceState: {
    /* Head block hash */
    headBlockHash: string;
    /* Safe block hash */
    safeBlockHash: string;
    /* Finalized block hash */
    finalizedBlockHash: string;
}, payloadAttributes?: {
    /* Timestamp */
    timestamp: string;
    /* Previous randao value */
    prevRandao: string;
    /* Suggested fee recipient */
    suggestedFeeRecipient: string;
    /* Withdrawals */
    withdrawals: {
            /* Withdrawal index */
            index: string;
            /* Validator index */
            validatorIndex: string;
            /* Withdrawal address */
            address: string;
            /* Withdrawal amount */
            amount: string;
        }[];
}): Promise<{
    /* Payload status */
    payloadStatus: {
        /* Payload validation status */
        status: 'VALID' | 'INVALID' | 'SYNCING';
        /* The hash of the most recent valid block */
        latestValidHash: string;
        /* Validation error message */
        validationError: string;
    };
    /* Payload id */
    payloadId: string;
}> {
    return this.request({ method: 'engine_forkchoiceUpdatedV2', params: Array.from(arguments) })
}

/**
 * Runs execution payload validation <eth> 
 * 
 * @param executionPayload - 
 * @returns Payload status - 
 */
engine_newPayloadV1(executionPayload: {
    /* Parent block hash */
    parentHash: string;
    /* Recipient of transaction priority fees */
    feeRecipient: string;
    /* State root */
    stateRoot: string;
    /* Receipts root */
    receiptsRoot: string;
    /* Bloom filter */
    logsBloom: string;
    /* Previous randao value */
    prevRandao: string;
    /* Block number */
    blockNumber: string;
    /* Gas limit */
    gasLimit: string;
    /* Gas used */
    gasUsed: string;
    /* Timestamp */
    timestamp: string;
    /* Extra data */
    extraData: string;
    /* Base fee per gas */
    baseFeePerGas: string;
    /* Block hash */
    blockHash: string;
    /* Transactions */
    transactions: string[];
}): Promise<{
    /* Payload validation status */
    status: 'VALID' | 'INVALID' | 'SYNCING' | 'ACCEPTED' | 'INVALID_BLOCK_HASH';
    /* The hash of the most recent valid block */
    latestValidHash: string;
    /* Validation error message */
    validationError: string;
}> {
    return this.request({ method: 'engine_newPayloadV1', params: Array.from(arguments) })
}

/**
 * Runs execution payload validation <eth> 
 * 
 * @param executionPayload - 
 * @returns Payload status - 
 */
engine_newPayloadV2(executionPayload: {
    /* Parent block hash */
    parentHash: string;
    /* Recipient of transaction priority fees */
    feeRecipient: string;
    /* State root */
    stateRoot: string;
    /* Receipts root */
    receiptsRoot: string;
    /* Bloom filter */
    logsBloom: string;
    /* Previous randao value */
    prevRandao: string;
    /* Block number */
    blockNumber: string;
    /* Gas limit */
    gasLimit: string;
    /* Gas used */
    gasUsed: string;
    /* Timestamp */
    timestamp: string;
    /* Extra data */
    extraData: string;
    /* Base fee per gas */
    baseFeePerGas: string;
    /* Block hash */
    blockHash: string;
    /* Transactions */
    transactions: string[];
} | {
    /* Parent block hash */
    parentHash: string;
    /* Recipient of transaction priority fees */
    feeRecipient: string;
    /* State root */
    stateRoot: string;
    /* Receipts root */
    receiptsRoot: string;
    /* Bloom filter */
    logsBloom: string;
    /* Previous randao value */
    prevRandao: string;
    /* Block number */
    blockNumber: string;
    /* Gas limit */
    gasLimit: string;
    /* Gas used */
    gasUsed: string;
    /* Timestamp */
    timestamp: string;
    /* Extra data */
    extraData: string;
    /* Base fee per gas */
    baseFeePerGas: string;
    /* Block hash */
    blockHash: string;
    /* Transactions */
    transactions: string[];
    /* Withdrawals */
    withdrawals: {
            /* Withdrawal index */
            index: string;
            /* Validator index */
            validatorIndex: string;
            /* Withdrawal address */
            address: string;
            /* Withdrawal amount */
            amount: string;
        }[];
}): Promise<{
    /* Payload validation status */
    status: 'VALID' | 'INVALID' | 'SYNCING' | 'ACCEPTED';
    /* The hash of the most recent valid block */
    latestValidHash: string;
    /* Validation error message */
    validationError: string;
}> {
    return this.request({ method: 'engine_newPayloadV2', params: Array.from(arguments) })
}

/**
 * Obtains execution payload from payload build process <eth> 
 * 
 * @param payloadId - 
 * @returns Execution payload - 
 */
engine_getPayloadV1(payloadId: string): Promise<{
    /* Parent block hash */
    parentHash: string;
    /* Recipient of transaction priority fees */
    feeRecipient: string;
    /* State root */
    stateRoot: string;
    /* Receipts root */
    receiptsRoot: string;
    /* Bloom filter */
    logsBloom: string;
    /* Previous randao value */
    prevRandao: string;
    /* Block number */
    blockNumber: string;
    /* Gas limit */
    gasLimit: string;
    /* Gas used */
    gasUsed: string;
    /* Timestamp */
    timestamp: string;
    /* Extra data */
    extraData: string;
    /* Base fee per gas */
    baseFeePerGas: string;
    /* Block hash */
    blockHash: string;
    /* Transactions */
    transactions: string[];
}> {
    return this.request({ method: 'engine_getPayloadV1', params: Array.from(arguments) })
}

/**
 * Obtains execution payload from payload build process <eth> 
 * 
 * @param payloadId - 
 * @returns Response object - 
 */
engine_getPayloadV2(payloadId: string): Promise<{
    /* Execution payload */
    executionPayload: {
    /* Parent block hash */
    parentHash: string;
    /* Recipient of transaction priority fees */
    feeRecipient: string;
    /* State root */
    stateRoot: string;
    /* Receipts root */
    receiptsRoot: string;
    /* Bloom filter */
    logsBloom: string;
    /* Previous randao value */
    prevRandao: string;
    /* Block number */
    blockNumber: string;
    /* Gas limit */
    gasLimit: string;
    /* Gas used */
    gasUsed: string;
    /* Timestamp */
    timestamp: string;
    /* Extra data */
    extraData: string;
    /* Base fee per gas */
    baseFeePerGas: string;
    /* Block hash */
    blockHash: string;
    /* Transactions */
    transactions: string[];
} | {
    /* Parent block hash */
    parentHash: string;
    /* Recipient of transaction priority fees */
    feeRecipient: string;
    /* State root */
    stateRoot: string;
    /* Receipts root */
    receiptsRoot: string;
    /* Bloom filter */
    logsBloom: string;
    /* Previous randao value */
    prevRandao: string;
    /* Block number */
    blockNumber: string;
    /* Gas limit */
    gasLimit: string;
    /* Gas used */
    gasUsed: string;
    /* Timestamp */
    timestamp: string;
    /* Extra data */
    extraData: string;
    /* Base fee per gas */
    baseFeePerGas: string;
    /* Block hash */
    blockHash: string;
    /* Transactions */
    transactions: string[];
    /* Withdrawals */
    withdrawals: {
            /* Withdrawal index */
            index: string;
            /* Validator index */
            validatorIndex: string;
            /* Withdrawal address */
            address: string;
            /* Withdrawal amount */
            amount: string;
        }[];
};
    /* Expected fee value */
    blockValue: string;
}> {
    return this.request({ method: 'engine_getPayloadV2', params: Array.from(arguments) })
}

/**
 * Given block hashes returns bodies of the corresponding execution payloads <eth> 
 * 
 * @param arrayOfBlockHashes - 
 * @returns Execution payload bodies - 
 */
engine_getPayloadBodiesByHashV1(arrayOfBlockHashes: string[]): Promise<{
        /* Transactions */
        transactions: string[];
        /* Withdrawals */
        withdrawals: {
                /* Withdrawal index */
                index: string;
                /* Validator index */
                validatorIndex: string;
                /* Withdrawal address */
                address: string;
                /* Withdrawal amount */
                amount: string;
            }[];
    }[]> {
    return this.request({ method: 'engine_getPayloadBodiesByHashV1', params: Array.from(arguments) })
}

/**
 * Given a range of block numbers returns bodies of the corresponding execution payloads <eth> 
 * 
 * @param startingBlockNumber - 
 * @param numberOfBlocksToReturn - 
 * @returns Execution payload bodies - 
 */
engine_getPayloadBodiesByRangeV1(startingBlockNumber: string, numberOfBlocksToReturn: string): Promise<{
        /* Transactions */
        transactions: string[];
        /* Withdrawals */
        withdrawals: {
                /* Withdrawal index */
                index: string;
                /* Validator index */
                validatorIndex: string;
                /* Withdrawal address */
                address: string;
                /* Withdrawal amount */
                amount: string;
            }[];
    }[]> {
    return this.request({ method: 'engine_getPayloadBodiesByRangeV1', params: Array.from(arguments) })
}

/**
 * Exchanges transition configuration <eth> 
 * 
 * @param consensusClientConfiguration - 
 * @returns Execution client configuration - 
 */
engine_exchangeTransitionConfigurationV1(consensusClientConfiguration: {
    /* Terminal total difficulty */
    terminalTotalDifficulty: string;
    /* Terminal block hash */
    terminalBlockHash: string;
    /* Terminal block number */
    terminalBlockNumber: string;
}): Promise<{
    /* Terminal total difficulty */
    terminalTotalDifficulty: string;
    /* Terminal block hash */
    terminalBlockHash: string;
    /* Terminal block number */
    terminalBlockNumber: string;
}> {
    return this.request({ method: 'engine_exchangeTransitionConfigurationV1', params: Array.from(arguments) })
}
    protected returnSchemas = {
    "methods": {
        "eth_subscribe": "string",
        "eth_unsubscribe": "boolean",
        "wallet_addEthereumChain": "undefined",
        "wallet_switchEthereumChain": "undefined",
        "wallet_requestPermissions": [
            "Permission"
        ],
        "wallet_getPermissions": [
            "Permission"
        ],
        "wallet_registerOnboarding": "boolean",
        "wallet_watchAsset": "boolean",
        "eth_decrypt": [
            "Permission"
        ],
        "eth_getEncryptionPublicKey": "string",
        "eth_requestAccounts": [
            "string"
        ],
        "eth_accounts": [
            "string"
        ],
        "eth_signTypedData_v4": "string",
        "personal_sign": "string",
        "eth_sendTransaction": "string",
        "eth_blockNumber": "number",
        "eth_call": "string",
        "eth_chainId": "number",
        "eth_coinbase": "string",
        "eth_estimateGas": "bigint",
        "eth_feeHistory": {
            "oldestBlock": "bigint",
            "baseFeePerGas": [
                "bigint"
            ],
            "gasUsedRatio": [
                "number"
            ],
            "reward": [
                [
                    "bigint"
                ]
            ]
        },
        "eth_gasPrice": "bigint",
        "eth_getBalance": "bigint",
        "eth_getBlockByHash": "Block",
        "eth_getBlockByNumber": "Block",
        "eth_getBlockTransactionCountByHash": "bigint",
        "eth_getBlockTransactionCountByNumber": "bigint",
        "eth_getCode": "string",
        "eth_getFilterChanges": "FilterResults",
        "eth_getFilterLogs": "FilterResults",
        "eth_getLogs": "FilterResults",
        "eth_getProof": "AccountProof",
        "eth_getStorageAt": "string",
        "eth_getTransactionByBlockHashAndIndex": "TransactionInfo",
        "eth_getTransactionByBlockNumberAndIndex": "TransactionInfo",
        "eth_getTransactionByHash": "TransactionInfo",
        "eth_getTransactionCount": "bigint",
        "eth_getTransactionReceipt": "ReceiptInfo",
        "eth_getUncleCountByBlockHash": "bigint",
        "eth_getUncleCountByBlockNumber": "bigint",
        "eth_maxPriorityFeePerGas": "bigint",
        "eth_newBlockFilter": "bigint",
        "eth_newFilter": "bigint",
        "eth_newPendingTransactionFilter": "bigint",
        "eth_sendRawTransaction": "string",
        "eth_syncing": "SyncingStatus",
        "eth_uninstallFilter": "boolean",
        "web3_clientVersion": "string",
        "web3_sha3": "string",
        "net_listening": "boolean",
        "net_peerCount": "string",
        "net_version": "string",
        "eth_getRawTransactionByHash": "string",
        "eth_getRawTransactionByBlockHashAndIndex": "string",
        "eth_getRawTransactionByBlockNumberAndIndex": "string",
        "eth_getUncleByBlockHashAndIndex": "undefined",
        "eth_getUncleByBlockNumberAndIndex": "undefined",
        "eth_hashrate": "bigint",
        "eth_mining": "boolean",
        "eth_pendingTransactions": [
            "Transaction"
        ],
        "eth_protocolVersion": "bigint",
        "eth_submitHashrate": "boolean",
        "eth_submitWork": "boolean",
        "eth_createAccessList": {
            "accessList": [
                {
                    "address": "string",
                    "storageKeys": [
                        "string"
                    ]
                }
            ],
            "error": "string",
            "gasUsed": "string"
        },
        "eth_sign": "string",
        "eth_signTransaction": "string",
        "debug_getRawHeader": "string",
        "debug_getRawBlock": "string",
        "debug_getRawTransaction": "string",
        "debug_getRawReceipts": [
            "string"
        ],
        "debug_getBadBlocks": [
            {
                "block": "string",
                "hash": "string",
                "rlp": "string"
            }
        ],
        "engine_exchangeCapabilities": [
            "string"
        ],
        "engine_forkchoiceUpdatedV1": {
            "payloadStatus": {
                "status": "string",
                "latestValidHash": "string",
                "validationError": "string"
            },
            "payloadId": "string"
        },
        "engine_forkchoiceUpdatedV2": {
            "payloadStatus": {
                "status": "string",
                "latestValidHash": "string",
                "validationError": "string"
            },
            "payloadId": "string"
        },
        "engine_newPayloadV1": {
            "status": "string",
            "latestValidHash": "string",
            "validationError": "string"
        },
        "engine_newPayloadV2": {
            "status": "string",
            "latestValidHash": "string",
            "validationError": "string"
        },
        "engine_getPayloadV1": {
            "parentHash": "string",
            "feeRecipient": "string",
            "stateRoot": "string",
            "receiptsRoot": "string",
            "logsBloom": "string",
            "prevRandao": "string",
            "blockNumber": "string",
            "gasLimit": "string",
            "gasUsed": "string",
            "timestamp": "string",
            "extraData": "string",
            "baseFeePerGas": "string",
            "blockHash": "string",
            "transactions": [
                "string"
            ]
        },
        "engine_getPayloadV2": {
            "executionPayload": {
                "parentHash": "string",
                "feeRecipient": "string",
                "stateRoot": "string",
                "receiptsRoot": "string",
                "logsBloom": "string",
                "prevRandao": "string",
                "blockNumber": "string",
                "gasLimit": "string",
                "gasUsed": "string",
                "timestamp": "string",
                "extraData": "string",
                "baseFeePerGas": "string",
                "blockHash": "string",
                "transactions": [
                    "string"
                ],
                "withdrawals": [
                    {
                        "index": "string",
                        "validatorIndex": "string",
                        "address": "string",
                        "amount": "string"
                    }
                ]
            },
            "blockValue": "string"
        },
        "engine_getPayloadBodiesByHashV1": [
            {
                "transactions": [
                    "string"
                ],
                "withdrawals": [
                    {
                        "index": "string",
                        "validatorIndex": "string",
                        "address": "string",
                        "amount": "string"
                    }
                ]
            }
        ],
        "engine_getPayloadBodiesByRangeV1": [
            {
                "transactions": [
                    "string"
                ],
                "withdrawals": [
                    {
                        "index": "string",
                        "validatorIndex": "string",
                        "address": "string",
                        "amount": "string"
                    }
                ]
            }
        ],
        "engine_exchangeTransitionConfigurationV1": {
            "terminalTotalDifficulty": "string",
            "terminalBlockHash": "string",
            "terminalBlockNumber": "string"
        }
    },
    "schemas": {
        "Permission": {
            "id": "string",
            "@context": [
                "string"
            ],
            "invoker": "string",
            "caveats": [
                {
                    "type": "string",
                    "name": "string"
                }
            ]
        },
        "Block": {
            "hash": "string",
            "parentHash": "string",
            "sha3Uncles": "string",
            "miner": "string",
            "stateRoot": "string",
            "transactionsRoot": "string",
            "receiptsRoot": "string",
            "logsBloom": "string",
            "difficulty": "bigint",
            "number": "number",
            "gasLimit": "bigint",
            "gasUsed": "bigint",
            "timestamp": "number",
            "extraData": "string",
            "mixHash": "string",
            "nonce": "string",
            "totalDifficulty": "bigint",
            "baseFeePerGas": "bigint",
            "withdrawalsRoot": "string",
            "size": "bigint",
            "transactions": {
                "oneOf": [
                    [
                        "string"
                    ],
                    [
                        "TransactionInfo"
                    ]
                ]
            },
            "withdrawals": [
                "Withdrawal"
            ],
            "uncles": [
                "string"
            ]
        },
        "FilterResults": {
            "oneOf": [
                [
                    "string"
                ],
                [
                    "Log"
                ]
            ]
        },
        "AccountProof": {
            "address": "string",
            "accountProof": [
                "string"
            ],
            "balance": "bigint",
            "codeHash": "string",
            "nonce": "bigint",
            "storageHash": "string",
            "storageProof": [
                "StorageProof"
            ]
        },
        "TransactionInfo": {
            "allOf": [
                {
                    "blockHash": "string",
                    "blockNumber": "number",
                    "from": "string",
                    "hash": "string",
                    "transactionIndex": "number"
                },
                "TransactionSigned"
            ]
        },
        "ReceiptInfo": {
            "type": "number",
            "transactionHash": "string",
            "transactionIndex": "bigint",
            "blockHash": "string",
            "blockNumber": "number",
            "from": "string",
            "to": "string",
            "cumulativeGasUsed": "bigint",
            "gasUsed": "bigint",
            "contractAddress": "string",
            "logs": [
                "Log"
            ],
            "logsBloom": "string",
            "root": "string",
            "status": "number",
            "effectiveGasPrice": "bigint"
        },
        "SyncingStatus": {
            "oneOf": [
                {
                    "startingBlock": "bigint",
                    "currentBlock": "bigint",
                    "highestBlock": "bigint"
                },
                "boolean"
            ]
        },
        "Transaction": {
            "blockHash": "undefined",
            "blockNumber": "undefined",
            "from": "string",
            "gas": "string",
            "gasPrice": "string",
            "hash": "string",
            "input": "string",
            "nonce": "bigint",
            "to": "string",
            "transactionIndex": "bigint",
            "value": "string",
            "v": "number",
            "r": "string",
            "s": "string"
        }
    }
};
    public req = {
eth_unsubscribe(subscriptionId: string):  { method: string, params: any[] } {
    return { method: 'eth_unsubscribe', params: Array.from(arguments) };
},
wallet_addEthereumChain(addEthereumChainParameter?: DataLike<RpcTypes.AddEthereumChainParameter>):  { method: string, params: any[] } {
    return { method: 'wallet_addEthereumChain', params: Array.from(arguments) };
},
wallet_switchEthereumChain(switchEthereumChainParameter?: {
    chainId: string;
}):  { method: string, params: any[] } {
    return { method: 'wallet_switchEthereumChain', params: Array.from(arguments) };
},
wallet_requestPermissions(requestPermissionsObject: {
    eth_accounts: {
        [key: string]: any
    };
    [key: string]: {
        [key: string]: any
    }
}):  { method: string, params: any[] } {
    return { method: 'wallet_requestPermissions', params: Array.from(arguments) };
},
wallet_getPermissions():  { method: string, params: any[] } {
    return { method: 'wallet_getPermissions', params: Array.from(arguments) };
},
wallet_registerOnboarding():  { method: string, params: any[] } {
    return { method: 'wallet_registerOnboarding', params: Array.from(arguments) };
},
wallet_watchAsset(type: 'ERC20' | 'ERC721' | 'ERC1155', options?: {
    address: string;
    symbol: string;
    decimals: number;
    image: string;
    tokenId: string;
}):  { method: string, params: any[] } {
    return { method: 'wallet_watchAsset', params: Array.from(arguments) };
},
eth_decrypt(encryptedMessage: string, address: TEth.Address):  { method: string, params: any[] } {
    return { method: 'eth_decrypt', params: Array.from(arguments) };
},
eth_getEncryptionPublicKey(address: TEth.Address):  { method: string, params: any[] } {
    return { method: 'eth_getEncryptionPublicKey', params: Array.from(arguments) };
},
eth_requestAccounts():  { method: string, params: any[] } {
    return { method: 'eth_requestAccounts', params: Array.from(arguments) };
},
eth_accounts():  { method: string, params: any[] } {
    return { method: 'eth_accounts', params: Array.from(arguments) };
},
eth_signTypedData_v4(address: TEth.Address, typedData: DataLike<RpcTypes.TypedData>):  { method: string, params: any[] } {
    return { method: 'eth_signTypedData_v4', params: Array.from(arguments) };
},
personal_sign(challenge: string, address: TEth.Address):  { method: string, params: any[] } {
    return { method: 'personal_sign', params: Array.from(arguments) };
},
eth_sendTransaction(transaction: {
    to: TEth.Address;
    from: TEth.Address;
    gas: bigint;
    value: bigint;
    data: TEth.Hex;
    gasPrice: bigint;
    maxPriorityFeePerGas: bigint;
    maxFeePerGas: bigint;
}):  { method: string, params: any[] } {
    return { method: 'eth_sendTransaction', params: Array.from(arguments) };
},
eth_blockNumber():  { method: string, params: any[] } {
    return { method: 'eth_blockNumber', params: Array.from(arguments) };
},
eth_call(transaction: DataLike<RpcTypes.GenericTransaction>, block?: DataLike<RpcTypes.BlockNumberOrTagOrHash>):  { method: string, params: any[] } {
    return { method: 'eth_call', params: Array.from(arguments) };
},
eth_chainId():  { method: string, params: any[] } {
    return { method: 'eth_chainId', params: Array.from(arguments) };
},
eth_coinbase():  { method: string, params: any[] } {
    return { method: 'eth_coinbase', params: Array.from(arguments) };
},
eth_estimateGas(transaction: DataLike<RpcTypes.GenericTransaction>, block?: DataLike<RpcTypes.BlockNumberOrTag>):  { method: string, params: any[] } {
    return { method: 'eth_estimateGas', params: Array.from(arguments) };
},
eth_feeHistory(blockCount: bigint, newestBlock: DataLike<RpcTypes.BlockNumberOrTag>, rewardPercentiles: number[]):  { method: string, params: any[] } {
    return { method: 'eth_feeHistory', params: Array.from(arguments) };
},
eth_gasPrice():  { method: string, params: any[] } {
    return { method: 'eth_gasPrice', params: Array.from(arguments) };
},
eth_getBalance(address: TEth.Address, block?: DataLike<RpcTypes.BlockNumberOrTagOrHash>):  { method: string, params: any[] } {
    return { method: 'eth_getBalance', params: Array.from(arguments) };
},
eth_getBlockByHash(blockHash: TEth.Hex, hydratedTransactions: boolean):  { method: string, params: any[] } {
    return { method: 'eth_getBlockByHash', params: Array.from(arguments) };
},
eth_getBlockByNumber(block: DataLike<RpcTypes.BlockNumberOrTag>, hydratedTransactions: boolean):  { method: string, params: any[] } {
    return { method: 'eth_getBlockByNumber', params: Array.from(arguments) };
},
eth_getBlockTransactionCountByHash(blockHash?: TEth.Hex):  { method: string, params: any[] } {
    return { method: 'eth_getBlockTransactionCountByHash', params: Array.from(arguments) };
},
eth_getBlockTransactionCountByNumber(block?: DataLike<RpcTypes.BlockNumberOrTag>):  { method: string, params: any[] } {
    return { method: 'eth_getBlockTransactionCountByNumber', params: Array.from(arguments) };
},
eth_getCode(address: TEth.Address, block: DataLike<RpcTypes.BlockNumberOrTagOrHash>):  { method: string, params: any[] } {
    return { method: 'eth_getCode', params: Array.from(arguments) };
},
eth_getFilterChanges(filterIdentifier?: bigint):  { method: string, params: any[] } {
    return { method: 'eth_getFilterChanges', params: Array.from(arguments) };
},
eth_getFilterLogs(filterIdentifier?: bigint):  { method: string, params: any[] } {
    return { method: 'eth_getFilterLogs', params: Array.from(arguments) };
},
eth_getLogs(filter?: DataLike<RpcTypes.Filter>):  { method: string, params: any[] } {
    return { method: 'eth_getLogs', params: Array.from(arguments) };
},
eth_getProof(address: TEth.Address, storageKeys: TEth.Hex[], block: DataLike<RpcTypes.BlockNumberOrTagOrHash>):  { method: string, params: any[] } {
    return { method: 'eth_getProof', params: Array.from(arguments) };
},
eth_getStorageAt(address: TEth.Address, storageSlot: bigint, block?: DataLike<RpcTypes.BlockNumberOrTagOrHash>):  { method: string, params: any[] } {
    return { method: 'eth_getStorageAt', params: Array.from(arguments) };
},
eth_getTransactionByBlockHashAndIndex(blockHash: TEth.Hex, transactionIndex: bigint):  { method: string, params: any[] } {
    return { method: 'eth_getTransactionByBlockHashAndIndex', params: Array.from(arguments) };
},
eth_getTransactionByBlockNumberAndIndex(block: DataLike<RpcTypes.BlockNumberOrTag>, transactionIndex: bigint):  { method: string, params: any[] } {
    return { method: 'eth_getTransactionByBlockNumberAndIndex', params: Array.from(arguments) };
},
eth_getTransactionByHash(transactionHash: TEth.Hex):  { method: string, params: any[] } {
    return { method: 'eth_getTransactionByHash', params: Array.from(arguments) };
},
eth_getTransactionCount(address: TEth.Address, block?: DataLike<RpcTypes.BlockNumberOrTagOrHash>):  { method: string, params: any[] } {
    return { method: 'eth_getTransactionCount', params: Array.from(arguments) };
},
eth_getTransactionReceipt(transactionHash: TEth.Hex):  { method: string, params: any[] } {
    return { method: 'eth_getTransactionReceipt', params: Array.from(arguments) };
},
eth_getUncleCountByBlockHash(blockHash?: TEth.Hex):  { method: string, params: any[] } {
    return { method: 'eth_getUncleCountByBlockHash', params: Array.from(arguments) };
},
eth_getUncleCountByBlockNumber(block?: DataLike<RpcTypes.BlockNumberOrTag>):  { method: string, params: any[] } {
    return { method: 'eth_getUncleCountByBlockNumber', params: Array.from(arguments) };
},
eth_maxPriorityFeePerGas():  { method: string, params: any[] } {
    return { method: 'eth_maxPriorityFeePerGas', params: Array.from(arguments) };
},
eth_newBlockFilter():  { method: string, params: any[] } {
    return { method: 'eth_newBlockFilter', params: Array.from(arguments) };
},
eth_newFilter(filter?: DataLike<RpcTypes.Filter>):  { method: string, params: any[] } {
    return { method: 'eth_newFilter', params: Array.from(arguments) };
},
eth_newPendingTransactionFilter():  { method: string, params: any[] } {
    return { method: 'eth_newPendingTransactionFilter', params: Array.from(arguments) };
},
eth_sendRawTransaction(transaction: TEth.Hex):  { method: string, params: any[] } {
    return { method: 'eth_sendRawTransaction', params: Array.from(arguments) };
},
eth_syncing():  { method: string, params: any[] } {
    return { method: 'eth_syncing', params: Array.from(arguments) };
},
eth_uninstallFilter(filterIdentifier?: bigint):  { method: string, params: any[] } {
    return { method: 'eth_uninstallFilter', params: Array.from(arguments) };
},
web3_clientVersion():  { method: string, params: any[] } {
    return { method: 'web3_clientVersion', params: Array.from(arguments) };
},
web3_sha3(data?: string):  { method: string, params: any[] } {
    return { method: 'web3_sha3', params: Array.from(arguments) };
},
net_listening():  { method: string, params: any[] } {
    return { method: 'net_listening', params: Array.from(arguments) };
},
net_peerCount():  { method: string, params: any[] } {
    return { method: 'net_peerCount', params: Array.from(arguments) };
},
net_version():  { method: string, params: any[] } {
    return { method: 'net_version', params: Array.from(arguments) };
},
eth_getRawTransactionByHash(transactionHash?: string):  { method: string, params: any[] } {
    return { method: 'eth_getRawTransactionByHash', params: Array.from(arguments) };
},
eth_getRawTransactionByBlockHashAndIndex(blockHash?: string, index?: bigint):  { method: string, params: any[] } {
    return { method: 'eth_getRawTransactionByBlockHashAndIndex', params: Array.from(arguments) };
},
eth_getRawTransactionByBlockNumberAndIndex(blockNumber?: bigint, index?: bigint):  { method: string, params: any[] } {
    return { method: 'eth_getRawTransactionByBlockNumberAndIndex', params: Array.from(arguments) };
},
eth_getUncleByBlockHashAndIndex(blockHash?: string, index?: bigint):  { method: string, params: any[] } {
    return { method: 'eth_getUncleByBlockHashAndIndex', params: Array.from(arguments) };
},
eth_getUncleByBlockNumberAndIndex(uncleBlockNumber: bigint, index: bigint):  { method: string, params: any[] } {
    return { method: 'eth_getUncleByBlockNumberAndIndex', params: Array.from(arguments) };
},
eth_getWork():  { method: string, params: any[] } {
    return { method: 'eth_getWork', params: Array.from(arguments) };
},
eth_hashrate():  { method: string, params: any[] } {
    return { method: 'eth_hashrate', params: Array.from(arguments) };
},
eth_mining():  { method: string, params: any[] } {
    return { method: 'eth_mining', params: Array.from(arguments) };
},
eth_pendingTransactions():  { method: string, params: any[] } {
    return { method: 'eth_pendingTransactions', params: Array.from(arguments) };
},
eth_protocolVersion():  { method: string, params: any[] } {
    return { method: 'eth_protocolVersion', params: Array.from(arguments) };
},
eth_submitHashrate(hashRate: string, id: string):  { method: string, params: any[] } {
    return { method: 'eth_submitHashrate', params: Array.from(arguments) };
},
eth_submitWork(nonce?: bigint, powHash?: string, mixHash?: string):  { method: string, params: any[] } {
    return { method: 'eth_submitWork', params: Array.from(arguments) };
},
eth_createAccessList(transaction: {
    /* type */
    type: string;
    /* nonce */
    nonce: string;
    /* to address */
    to: string;
    /* from address */
    from: string;
    /* gas limit */
    gas: string;
    /* value */
    value: string;
    /* input data */
    input: string;
    /* gas price */
    gasPrice: string;
    /* max priority fee per gas */
    maxPriorityFeePerGas: string;
    /* max fee per gas */
    maxFeePerGas: string;
    /* accessList */
    accessList: {
            /* hex encoded address */
            address: string;
            storageKeys: string[];
        }[];
    /* chainId */
    chainId: string;
}, block?: string | 'earliest' | 'finalized' | 'safe' | 'latest' | 'pending'):  { method: string, params: any[] } {
    return { method: 'eth_createAccessList', params: Array.from(arguments) };
},
eth_sign(address: string, message: string):  { method: string, params: any[] } {
    return { method: 'eth_sign', params: Array.from(arguments) };
},
eth_signTransaction(transaction: {
    /* type */
    type: string;
    /* nonce */
    nonce: string;
    /* to address */
    to: string;
    /* from address */
    from: string;
    /* gas limit */
    gas: string;
    /* value */
    value: string;
    /* input data */
    input: string;
    /* gas price */
    gasPrice: string;
    /* max priority fee per gas */
    maxPriorityFeePerGas: string;
    /* max fee per gas */
    maxFeePerGas: string;
    /* accessList */
    accessList: {
            /* hex encoded address */
            address: string;
            storageKeys: string[];
        }[];
    /* chainId */
    chainId: string;
}):  { method: string, params: any[] } {
    return { method: 'eth_signTransaction', params: Array.from(arguments) };
},
debug_getRawHeader(block: string | 'earliest' | 'finalized' | 'safe' | 'latest' | 'pending'):  { method: string, params: any[] } {
    return { method: 'debug_getRawHeader', params: Array.from(arguments) };
},
debug_getRawBlock(block: string | 'earliest' | 'finalized' | 'safe' | 'latest' | 'pending'):  { method: string, params: any[] } {
    return { method: 'debug_getRawBlock', params: Array.from(arguments) };
},
debug_getRawTransaction(transactionHash: string):  { method: string, params: any[] } {
    return { method: 'debug_getRawTransaction', params: Array.from(arguments) };
},
debug_getRawReceipts(block: string | 'earliest' | 'finalized' | 'safe' | 'latest' | 'pending'):  { method: string, params: any[] } {
    return { method: 'debug_getRawReceipts', params: Array.from(arguments) };
},
debug_getBadBlocks():  { method: string, params: any[] } {
    return { method: 'debug_getBadBlocks', params: Array.from(arguments) };
},
engine_exchangeCapabilities(consensusClientMethods: string[]):  { method: string, params: any[] } {
    return { method: 'engine_exchangeCapabilities', params: Array.from(arguments) };
},
engine_forkchoiceUpdatedV1(forkchoiceState: {
    /* Head block hash */
    headBlockHash: string;
    /* Safe block hash */
    safeBlockHash: string;
    /* Finalized block hash */
    finalizedBlockHash: string;
}, payloadAttributes?: {
    /* Timestamp */
    timestamp: string;
    /* Previous randao value */
    prevRandao: string;
    /* Suggested fee recipient */
    suggestedFeeRecipient: string;
}):  { method: string, params: any[] } {
    return { method: 'engine_forkchoiceUpdatedV1', params: Array.from(arguments) };
},
engine_forkchoiceUpdatedV2(forkchoiceState: {
    /* Head block hash */
    headBlockHash: string;
    /* Safe block hash */
    safeBlockHash: string;
    /* Finalized block hash */
    finalizedBlockHash: string;
}, payloadAttributes?: {
    /* Timestamp */
    timestamp: string;
    /* Previous randao value */
    prevRandao: string;
    /* Suggested fee recipient */
    suggestedFeeRecipient: string;
    /* Withdrawals */
    withdrawals: {
            /* Withdrawal index */
            index: string;
            /* Validator index */
            validatorIndex: string;
            /* Withdrawal address */
            address: string;
            /* Withdrawal amount */
            amount: string;
        }[];
}):  { method: string, params: any[] } {
    return { method: 'engine_forkchoiceUpdatedV2', params: Array.from(arguments) };
},
engine_newPayloadV1(executionPayload: {
    /* Parent block hash */
    parentHash: string;
    /* Recipient of transaction priority fees */
    feeRecipient: string;
    /* State root */
    stateRoot: string;
    /* Receipts root */
    receiptsRoot: string;
    /* Bloom filter */
    logsBloom: string;
    /* Previous randao value */
    prevRandao: string;
    /* Block number */
    blockNumber: string;
    /* Gas limit */
    gasLimit: string;
    /* Gas used */
    gasUsed: string;
    /* Timestamp */
    timestamp: string;
    /* Extra data */
    extraData: string;
    /* Base fee per gas */
    baseFeePerGas: string;
    /* Block hash */
    blockHash: string;
    /* Transactions */
    transactions: string[];
}):  { method: string, params: any[] } {
    return { method: 'engine_newPayloadV1', params: Array.from(arguments) };
},
engine_newPayloadV2(executionPayload: {
    /* Parent block hash */
    parentHash: string;
    /* Recipient of transaction priority fees */
    feeRecipient: string;
    /* State root */
    stateRoot: string;
    /* Receipts root */
    receiptsRoot: string;
    /* Bloom filter */
    logsBloom: string;
    /* Previous randao value */
    prevRandao: string;
    /* Block number */
    blockNumber: string;
    /* Gas limit */
    gasLimit: string;
    /* Gas used */
    gasUsed: string;
    /* Timestamp */
    timestamp: string;
    /* Extra data */
    extraData: string;
    /* Base fee per gas */
    baseFeePerGas: string;
    /* Block hash */
    blockHash: string;
    /* Transactions */
    transactions: string[];
} | {
    /* Parent block hash */
    parentHash: string;
    /* Recipient of transaction priority fees */
    feeRecipient: string;
    /* State root */
    stateRoot: string;
    /* Receipts root */
    receiptsRoot: string;
    /* Bloom filter */
    logsBloom: string;
    /* Previous randao value */
    prevRandao: string;
    /* Block number */
    blockNumber: string;
    /* Gas limit */
    gasLimit: string;
    /* Gas used */
    gasUsed: string;
    /* Timestamp */
    timestamp: string;
    /* Extra data */
    extraData: string;
    /* Base fee per gas */
    baseFeePerGas: string;
    /* Block hash */
    blockHash: string;
    /* Transactions */
    transactions: string[];
    /* Withdrawals */
    withdrawals: {
            /* Withdrawal index */
            index: string;
            /* Validator index */
            validatorIndex: string;
            /* Withdrawal address */
            address: string;
            /* Withdrawal amount */
            amount: string;
        }[];
}):  { method: string, params: any[] } {
    return { method: 'engine_newPayloadV2', params: Array.from(arguments) };
},
engine_getPayloadV1(payloadId: string):  { method: string, params: any[] } {
    return { method: 'engine_getPayloadV1', params: Array.from(arguments) };
},
engine_getPayloadV2(payloadId: string):  { method: string, params: any[] } {
    return { method: 'engine_getPayloadV2', params: Array.from(arguments) };
},
engine_getPayloadBodiesByHashV1(arrayOfBlockHashes: string[]):  { method: string, params: any[] } {
    return { method: 'engine_getPayloadBodiesByHashV1', params: Array.from(arguments) };
},
engine_getPayloadBodiesByRangeV1(startingBlockNumber: string, numberOfBlocksToReturn: string):  { method: string, params: any[] } {
    return { method: 'engine_getPayloadBodiesByRangeV1', params: Array.from(arguments) };
},
engine_exchangeTransitionConfigurationV1(consensusClientConfiguration: {
    /* Terminal total difficulty */
    terminalTotalDifficulty: string;
    /* Terminal block hash */
    terminalBlockHash: string;
    /* Terminal block number */
    terminalBlockNumber: string;
}):  { method: string, params: any[] } {
    return { method: 'engine_exchangeTransitionConfigurationV1', params: Array.from(arguments) };
},
    }
}
export namespace RpcTypes {

/** TypedData */
export type TypedData = {
    types: {
        EIP712Domain: any[];
        [key: string]: {
                name: string;
                type: string;
            }[]
    };
    domain: {
        [key: string]: any
    };
    primaryType: string;
    message: {
        [key: string]: any
    };
}


/** AddEthereumChainParameter */
export type AddEthereumChainParameter = {
    chainId: string;
    blockExplorerUrls: string[];
    chainName: string;
    iconUrls: string[];
    nativeCurrency: RpcTypes.NativeCurrency;
    rpcUrls: string[];
}


/** NativeCurrency */
export type NativeCurrency = {
    decimals: bigint;
    name: string;
    symbol: string;
}


/** Permission */
export type Permission = {
    id: string;
    '@context': string[];
    invoker: string;
    caveats: {
            /* Type */
            type: string;
            /* CaveatValue */
            value: any;
            /* Name */
            name: string;
        }[];
}


/** Block object */
export type Block = {
    hash: TEth.Hex;
    parentHash: TEth.Hex;
    sha3Uncles: TEth.Hex;
    miner: TEth.Address;
    stateRoot: TEth.Hex;
    transactionsRoot: TEth.Hex;
    receiptsRoot: TEth.Hex;
    logsBloom: TEth.Hex;
    difficulty: bigint;
    /* Number */
    number: number;
    gasLimit: bigint;
    gasUsed: bigint;
    /* Timestamp */
    timestamp: number;
    extraData: TEth.Hex;
    mixHash: TEth.Hex;
    nonce: TEth.Hex;
    totalDifficulty: bigint;
    baseFeePerGas: bigint;
    withdrawalsRoot: TEth.Hex;
    size: bigint;
    transactions: TEth.Hex[] | RpcTypes.TransactionInfo[];
    /* Withdrawals */
    withdrawals: RpcTypes.Withdrawal[];
    /* Uncles */
    uncles: TEth.Hex[];
}


/** Block number or tag */
export type BlockNumberOrTag = bigint | 'earliest' | 'finalized' | 'safe' | 'latest' | 'pending'


/** Block number, tag, or block hash */
export type BlockNumberOrTagOrHash = bigint | 'earliest' | 'finalized' | 'safe' | 'latest' | 'pending' | TEth.Hex


/** Syncing status */
export type SyncingStatus = {
    startingBlock: bigint;
    currentBlock: bigint;
    highestBlock: bigint;
} | boolean


/** Filter results */
export type FilterResults = TEth.Hex[] | RpcTypes.Log[]


/** filter */
export type Filter = {
    /* from block */
    fromBlock: number;
    /* to block */
    toBlock: number;
    /* Address(es) */
    address: TEth.Address | TEth.Address[];
    /* Filter Topics */
    topics: RpcTypes.FilterTopic[];
}


/** Filter Topic List Entry */
export type FilterTopic = TEth.Hex | TEth.Hex[]


/** log */
export type Log = {
    /* removed */
    removed: boolean;
    /* log index */
    logIndex: number;
    /* transaction index */
    transactionIndex: number;
    transactionHash: TEth.Hex;
    blockHash: TEth.Hex;
    /* block number */
    blockNumber: number;
    address: TEth.Address;
    data: TEth.Hex;
    /* topics */
    topics: TEth.Hex[];
}


/** Receipt information */
export type ReceiptInfo = {
    /* type */
    type: number;
    transactionHash: TEth.Hex;
    transactionIndex: bigint;
    blockHash: TEth.Hex;
    /* block number */
    blockNumber: number;
    from: TEth.Address;
    to: TEth.Address;
    cumulativeGasUsed: bigint;
    gasUsed: bigint;
    contractAddress: TEth.Address;
    /* logs */
    logs: RpcTypes.Log[];
    logsBloom: TEth.Hex;
    root: TEth.Hex;
    /* status */
    status: number;
    effectiveGasPrice: bigint;
}


/** Account proof */
export type AccountProof = {
    address: TEth.Address;
    /* accountProof */
    accountProof: TEth.Hex[];
    balance: bigint;
    codeHash: TEth.Hex;
    nonce: bigint;
    storageHash: TEth.Hex;
    /* Storage proofs */
    storageProof: RpcTypes.StorageProof[];
}


/** Storage proof */
export type StorageProof = {
    key: TEth.Hex;
    value: bigint;
    /* proof */
    proof: TEth.Hex[];
}


/** Access list entry */
export type AccessListEntry = {
    address: TEth.Address;
    storageKeys: TEth.Hex[];
}


/** EIP-1559 transaction. */
export type Transaction1559Unsigned = {
    /* type */
    type: number;
    /* nonce */
    nonce: number;
    to: TEth.Address;
    gas: bigint;
    value: bigint;
    input: TEth.Hex;
    maxPriorityFeePerGas: bigint;
    maxFeePerGas: bigint;
    gasPrice: bigint;
    /* Access list */
    accessList: RpcTypes.AccessListEntry[];
    /* chainId */
    chainId: number;
}


/** EIP-2930 transaction. */
export type Transaction2930Unsigned = {
    /* type */
    type: number;
    /* nonce */
    nonce: number;
    to: TEth.Address;
    gas: bigint;
    value: bigint;
    input: TEth.Hex;
    gasPrice: bigint;
    /* Access list */
    accessList: RpcTypes.AccessListEntry[];
    /* chainId */
    chainId: number;
}


/** Legacy transaction. */
export type TransactionLegacyUnsigned = {
    /* type */
    type: number;
    /* nonce */
    nonce: number;
    to: TEth.Address;
    gas: bigint;
    value: bigint;
    input: TEth.Hex;
    gasPrice: bigint;
    /* chainId */
    chainId: number;
}


/** Signed 1559 Transaction */
export type Transaction1559Signed = RpcTypes.Transaction1559Unsigned & {
    yParity: number;
    v: number;
    r: TEth.Hex;
    s: TEth.Hex;
}


/** Signed 2930 Transaction */
export type Transaction2930Signed = RpcTypes.Transaction2930Unsigned & {
    yParity: number;
    v: number;
    r: TEth.Hex;
    s: TEth.Hex;
}


/** Signed Legacy Transaction */
export type TransactionLegacySigned = RpcTypes.TransactionLegacyUnsigned & {
    v: number;
    r: TEth.Hex;
    s: TEth.Hex;
}


export type TransactionSigned = RpcTypes.Transaction1559Signed | RpcTypes.Transaction2930Signed | RpcTypes.TransactionLegacySigned


/** Transaction information */
export type TransactionInfo = {
    blockHash: TEth.Hex;
    /* block number */
    blockNumber: number;
    from: TEth.Address;
    hash: TEth.Hex;
    /* transaction index */
    transactionIndex: number;
} & RpcTypes.TransactionSigned


/** Transaction object generic to all types */
export type GenericTransaction = {
    type: number;
    nonce: bigint;
    to: TEth.Address;
    from: TEth.Address;
    gas: bigint;
    value: bigint;
    input: TEth.Hex;
    gasPrice: bigint;
    maxPriorityFeePerGas: bigint;
    maxFeePerGas: bigint;
    /* Access list */
    accessList: RpcTypes.AccessListEntry[];
    chainId: bigint;
}


/** Validator withdrawal */
export type Withdrawal = {
    index: bigint;
    validatorIndex: bigint;
    address: TEth.Address;
    amount: bigint;
}


/** transaction */
export type Transaction = {
    blockHash: undefined;
    blockNumber: undefined;
    /* hex encoded address */
    from: string;
    /* transactionGas */
    gas: string;
    /* transactionGasPrice */
    gasPrice: string;
    /* keccak */
    hash: string;
    /* transactionInput */
    input: string;
    nonce: bigint;
    /* hex encoded address */
    to: string;
    transactionIndex: bigint;
    /* keccak */
    value: string;
    /* transactionSigV */
    v: number;
    /* transactionSigR */
    r: TEth.Hex;
    /* transactionSigS */
    s: TEth.Hex;
}

}